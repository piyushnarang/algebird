// Autogenerated code DO NOT EDIT BY HAND

package com.twitter.algebird_internal.injection

import com.twitter.algebird_internal.{thriftscala => thrift}
import com.twitter.bijection.{AbstractInjection, Codec, Injection}

import thrift.Item
import java.nio.ByteBuffer

trait GeneratedTupleImplicits {
  import ThriftImplicits._
  implicit private val toBuf = Injection.connect[Item, Array[Byte], ByteBuffer]

  implicit def thriftTuple2[A, B](
    implicit injection: Injection[(A, B), (Item, Item)]
  ): Injection[(A, B), thrift.Tuple2] =
    new AbstractInjection[(A, B), thrift.Tuple2] {
      def apply(tuple: (A, B)) = {
        val (a, b) = injection(tuple)
        thrift.Tuple2(a, b)
      }
      override def invert(tuple: thrift.Tuple2) =
        injection.invert((tuple.a, tuple.b))
    }

  implicit def tuple2ToBytes[A, B](
    implicit injection: Injection[(A, B), (Item, Item)]
  ): Codec[(A, B)] =
    Injection.connect[(A, B), thrift.Tuple2, Array[Byte]]

  implicit def thriftTuple3[A, B, C](
    implicit injection: Injection[(A, B, C), (Item, Item, Item)]
  ): Injection[(A, B, C), thrift.Tuple3] =
    new AbstractInjection[(A, B, C), thrift.Tuple3] {
      def apply(tuple: (A, B, C)) = {
        val (a, b, c) = injection(tuple)
        thrift.Tuple3(a, b, c)
      }
      override def invert(tuple: thrift.Tuple3) =
        injection.invert((tuple.a, tuple.b, tuple.c))
    }

  implicit def tuple3ToBytes[A, B, C](
    implicit injection: Injection[(A, B, C), (Item, Item, Item)]
  ): Codec[(A, B, C)] =
    Injection.connect[(A, B, C), thrift.Tuple3, Array[Byte]]

  implicit def thriftTuple4[A, B, C, D](
    implicit injection: Injection[(A, B, C, D), (Item, Item, Item, Item)]
  ): Injection[(A, B, C, D), thrift.Tuple4] =
    new AbstractInjection[(A, B, C, D), thrift.Tuple4] {
      def apply(tuple: (A, B, C, D)) = {
        val (a, b, c, d) = injection(tuple)
        thrift.Tuple4(a, b, c, d)
      }
      override def invert(tuple: thrift.Tuple4) =
        injection.invert((tuple.a, tuple.b, tuple.c, tuple.d))
    }

  implicit def tuple4ToBytes[A, B, C, D](
    implicit injection: Injection[(A, B, C, D), (Item, Item, Item, Item)]
  ): Codec[(A, B, C, D)] =
    Injection.connect[(A, B, C, D), thrift.Tuple4, Array[Byte]]

  implicit def thriftTuple5[A, B, C, D, E](
    implicit injection: Injection[(A, B, C, D, E), (Item, Item, Item, Item, Item)]
  ): Injection[(A, B, C, D, E), thrift.Tuple5] =
    new AbstractInjection[(A, B, C, D, E), thrift.Tuple5] {
      def apply(tuple: (A, B, C, D, E)) = {
        val (a, b, c, d, e) = injection(tuple)
        thrift.Tuple5(a, b, c, d, e)
      }
      override def invert(tuple: thrift.Tuple5) =
        injection.invert((tuple.a, tuple.b, tuple.c, tuple.d, tuple.e))
    }

  implicit def tuple5ToBytes[A, B, C, D, E](
    implicit injection: Injection[(A, B, C, D, E), (Item, Item, Item, Item, Item)]
  ): Codec[(A, B, C, D, E)] =
    Injection.connect[(A, B, C, D, E), thrift.Tuple5, Array[Byte]]

  implicit def thriftTuple6[A, B, C, D, E, F](
    implicit injection: Injection[(A, B, C, D, E, F), (Item, Item, Item, Item, Item, Item)]
  ): Injection[(A, B, C, D, E, F), thrift.Tuple6] =
    new AbstractInjection[(A, B, C, D, E, F), thrift.Tuple6] {
      def apply(tuple: (A, B, C, D, E, F)) = {
        val (a, b, c, d, e, f) = injection(tuple)
        thrift.Tuple6(a, b, c, d, e, f)
      }
      override def invert(tuple: thrift.Tuple6) =
        injection.invert((tuple.a, tuple.b, tuple.c, tuple.d, tuple.e, tuple.f))
    }

  implicit def tuple6ToBytes[A, B, C, D, E, F](
    implicit injection: Injection[(A, B, C, D, E, F), (Item, Item, Item, Item, Item, Item)]
  ): Codec[(A, B, C, D, E, F)] =
    Injection.connect[(A, B, C, D, E, F), thrift.Tuple6, Array[Byte]]

  implicit def thriftTuple7[A, B, C, D, E, F, G](
    implicit injection: Injection[(A, B, C, D, E, F, G), (Item, Item, Item, Item, Item, Item, Item)]
  ): Injection[(A, B, C, D, E, F, G), thrift.Tuple7] =
    new AbstractInjection[(A, B, C, D, E, F, G), thrift.Tuple7] {
      def apply(tuple: (A, B, C, D, E, F, G)) = {
        val (a, b, c, d, e, f, g) = injection(tuple)
        thrift.Tuple7(a, b, c, d, e, f, g)
      }
      override def invert(tuple: thrift.Tuple7) =
        injection.invert((tuple.a, tuple.b, tuple.c, tuple.d, tuple.e, tuple.f, tuple.g))
    }

  implicit def tuple7ToBytes[A, B, C, D, E, F, G](
    implicit injection: Injection[(A, B, C, D, E, F, G), (Item, Item, Item, Item, Item, Item, Item)]
  ): Codec[(A, B, C, D, E, F, G)] =
    Injection.connect[(A, B, C, D, E, F, G), thrift.Tuple7, Array[Byte]]

  implicit def thriftTuple8[A, B, C, D, E, F, G, H](
    implicit injection: Injection[
      (A, B, C, D, E, F, G, H),
      (Item, Item, Item, Item, Item, Item, Item, Item)
    ]
  ): Injection[(A, B, C, D, E, F, G, H), thrift.Tuple8] =
    new AbstractInjection[(A, B, C, D, E, F, G, H), thrift.Tuple8] {
      def apply(tuple: (A, B, C, D, E, F, G, H)) = {
        val (a, b, c, d, e, f, g, h) = injection(tuple)
        thrift.Tuple8(a, b, c, d, e, f, g, h)
      }
      override def invert(tuple: thrift.Tuple8) =
        injection.invert((tuple.a, tuple.b, tuple.c, tuple.d, tuple.e, tuple.f, tuple.g, tuple.h))
    }

  implicit def tuple8ToBytes[A, B, C, D, E, F, G, H](
    implicit injection: Injection[
      (A, B, C, D, E, F, G, H),
      (Item, Item, Item, Item, Item, Item, Item, Item)
    ]
  ): Codec[(A, B, C, D, E, F, G, H)] =
    Injection.connect[(A, B, C, D, E, F, G, H), thrift.Tuple8, Array[Byte]]

  implicit def thriftTuple9[A, B, C, D, E, F, G, H, I](
    implicit injection: Injection[
      (A, B, C, D, E, F, G, H, I),
      (Item, Item, Item, Item, Item, Item, Item, Item, Item)
    ]
  ): Injection[(A, B, C, D, E, F, G, H, I), thrift.Tuple9] =
    new AbstractInjection[(A, B, C, D, E, F, G, H, I), thrift.Tuple9] {
      def apply(tuple: (A, B, C, D, E, F, G, H, I)) = {
        val (a, b, c, d, e, f, g, h, i) = injection(tuple)
        thrift.Tuple9(a, b, c, d, e, f, g, h, i)
      }
      override def invert(tuple: thrift.Tuple9) =
        injection.invert(
          (tuple.a, tuple.b, tuple.c, tuple.d, tuple.e, tuple.f, tuple.g, tuple.h, tuple.i)
        )
    }

  implicit def tuple9ToBytes[A, B, C, D, E, F, G, H, I](
    implicit injection: Injection[
      (A, B, C, D, E, F, G, H, I),
      (Item, Item, Item, Item, Item, Item, Item, Item, Item)
    ]
  ): Codec[(A, B, C, D, E, F, G, H, I)] =
    Injection.connect[(A, B, C, D, E, F, G, H, I), thrift.Tuple9, Array[Byte]]

  implicit def thriftTuple10[A, B, C, D, E, F, G, H, I, J](
    implicit injection: Injection[
      (A, B, C, D, E, F, G, H, I, J),
      (Item, Item, Item, Item, Item, Item, Item, Item, Item, Item)
    ]
  ): Injection[(A, B, C, D, E, F, G, H, I, J), thrift.Tuple10] =
    new AbstractInjection[(A, B, C, D, E, F, G, H, I, J), thrift.Tuple10] {
      def apply(tuple: (A, B, C, D, E, F, G, H, I, J)) = {
        val (a, b, c, d, e, f, g, h, i, j) = injection(tuple)
        thrift.Tuple10(a, b, c, d, e, f, g, h, i, j)
      }
      override def invert(tuple: thrift.Tuple10) =
        injection.invert(
          (tuple.a, tuple.b, tuple.c, tuple.d, tuple.e, tuple.f, tuple.g, tuple.h, tuple.i, tuple.j)
        )
    }

  implicit def tuple10ToBytes[A, B, C, D, E, F, G, H, I, J](
    implicit injection: Injection[
      (A, B, C, D, E, F, G, H, I, J),
      (Item, Item, Item, Item, Item, Item, Item, Item, Item, Item)
    ]
  ): Codec[(A, B, C, D, E, F, G, H, I, J)] =
    Injection.connect[(A, B, C, D, E, F, G, H, I, J), thrift.Tuple10, Array[Byte]]

  implicit def thriftTuple11[A, B, C, D, E, F, G, H, I, J, K](
    implicit injection: Injection[
      (A, B, C, D, E, F, G, H, I, J, K),
      (Item, Item, Item, Item, Item, Item, Item, Item, Item, Item, Item)
    ]
  ): Injection[(A, B, C, D, E, F, G, H, I, J, K), thrift.Tuple11] =
    new AbstractInjection[(A, B, C, D, E, F, G, H, I, J, K), thrift.Tuple11] {
      def apply(tuple: (A, B, C, D, E, F, G, H, I, J, K)) = {
        val (a, b, c, d, e, f, g, h, i, j, k) = injection(tuple)
        thrift.Tuple11(a, b, c, d, e, f, g, h, i, j, k)
      }
      override def invert(tuple: thrift.Tuple11) =
        injection.invert(
          (
            tuple.a,
            tuple.b,
            tuple.c,
            tuple.d,
            tuple.e,
            tuple.f,
            tuple.g,
            tuple.h,
            tuple.i,
            tuple.j,
            tuple.k
          )
        )
    }

  implicit def tuple11ToBytes[A, B, C, D, E, F, G, H, I, J, K](
    implicit injection: Injection[
      (A, B, C, D, E, F, G, H, I, J, K),
      (Item, Item, Item, Item, Item, Item, Item, Item, Item, Item, Item)
    ]
  ): Codec[(A, B, C, D, E, F, G, H, I, J, K)] =
    Injection.connect[(A, B, C, D, E, F, G, H, I, J, K), thrift.Tuple11, Array[Byte]]

  implicit def thriftTuple12[A, B, C, D, E, F, G, H, I, J, K, L](
    implicit injection: Injection[
      (A, B, C, D, E, F, G, H, I, J, K, L),
      (Item, Item, Item, Item, Item, Item, Item, Item, Item, Item, Item, Item)
    ]
  ): Injection[(A, B, C, D, E, F, G, H, I, J, K, L), thrift.Tuple12] =
    new AbstractInjection[(A, B, C, D, E, F, G, H, I, J, K, L), thrift.Tuple12] {
      def apply(tuple: (A, B, C, D, E, F, G, H, I, J, K, L)) = {
        val (a, b, c, d, e, f, g, h, i, j, k, l) = injection(tuple)
        thrift.Tuple12(a, b, c, d, e, f, g, h, i, j, k, l)
      }
      override def invert(tuple: thrift.Tuple12) =
        injection.invert(
          (
            tuple.a,
            tuple.b,
            tuple.c,
            tuple.d,
            tuple.e,
            tuple.f,
            tuple.g,
            tuple.h,
            tuple.i,
            tuple.j,
            tuple.k,
            tuple.l
          )
        )
    }

  implicit def tuple12ToBytes[A, B, C, D, E, F, G, H, I, J, K, L](
    implicit injection: Injection[
      (A, B, C, D, E, F, G, H, I, J, K, L),
      (Item, Item, Item, Item, Item, Item, Item, Item, Item, Item, Item, Item)
    ]
  ): Codec[(A, B, C, D, E, F, G, H, I, J, K, L)] =
    Injection.connect[(A, B, C, D, E, F, G, H, I, J, K, L), thrift.Tuple12, Array[Byte]]

  implicit def thriftTuple13[A, B, C, D, E, F, G, H, I, J, K, L, M](
    implicit injection: Injection[
      (A, B, C, D, E, F, G, H, I, J, K, L, M),
      (Item, Item, Item, Item, Item, Item, Item, Item, Item, Item, Item, Item, Item)
    ]
  ): Injection[(A, B, C, D, E, F, G, H, I, J, K, L, M), thrift.Tuple13] =
    new AbstractInjection[(A, B, C, D, E, F, G, H, I, J, K, L, M), thrift.Tuple13] {
      def apply(tuple: (A, B, C, D, E, F, G, H, I, J, K, L, M)) = {
        val (a, b, c, d, e, f, g, h, i, j, k, l, m) = injection(tuple)
        thrift.Tuple13(a, b, c, d, e, f, g, h, i, j, k, l, m)
      }
      override def invert(tuple: thrift.Tuple13) =
        injection.invert(
          (
            tuple.a,
            tuple.b,
            tuple.c,
            tuple.d,
            tuple.e,
            tuple.f,
            tuple.g,
            tuple.h,
            tuple.i,
            tuple.j,
            tuple.k,
            tuple.l,
            tuple.m
          )
        )
    }

  implicit def tuple13ToBytes[A, B, C, D, E, F, G, H, I, J, K, L, M](
    implicit injection: Injection[
      (A, B, C, D, E, F, G, H, I, J, K, L, M),
      (Item, Item, Item, Item, Item, Item, Item, Item, Item, Item, Item, Item, Item)
    ]
  ): Codec[(A, B, C, D, E, F, G, H, I, J, K, L, M)] =
    Injection.connect[(A, B, C, D, E, F, G, H, I, J, K, L, M), thrift.Tuple13, Array[Byte]]

  implicit def thriftTuple14[A, B, C, D, E, F, G, H, I, J, K, L, M, N](
    implicit injection: Injection[
      (A, B, C, D, E, F, G, H, I, J, K, L, M, N),
      (Item, Item, Item, Item, Item, Item, Item, Item, Item, Item, Item, Item, Item, Item)
    ]
  ): Injection[(A, B, C, D, E, F, G, H, I, J, K, L, M, N), thrift.Tuple14] =
    new AbstractInjection[(A, B, C, D, E, F, G, H, I, J, K, L, M, N), thrift.Tuple14] {
      def apply(tuple: (A, B, C, D, E, F, G, H, I, J, K, L, M, N)) = {
        val (a, b, c, d, e, f, g, h, i, j, k, l, m, n) = injection(tuple)
        thrift.Tuple14(a, b, c, d, e, f, g, h, i, j, k, l, m, n)
      }
      override def invert(tuple: thrift.Tuple14) =
        injection.invert(
          (
            tuple.a,
            tuple.b,
            tuple.c,
            tuple.d,
            tuple.e,
            tuple.f,
            tuple.g,
            tuple.h,
            tuple.i,
            tuple.j,
            tuple.k,
            tuple.l,
            tuple.m,
            tuple.n
          )
        )
    }

  implicit def tuple14ToBytes[A, B, C, D, E, F, G, H, I, J, K, L, M, N](
    implicit injection: Injection[
      (A, B, C, D, E, F, G, H, I, J, K, L, M, N),
      (Item, Item, Item, Item, Item, Item, Item, Item, Item, Item, Item, Item, Item, Item)
    ]
  ): Codec[(A, B, C, D, E, F, G, H, I, J, K, L, M, N)] =
    Injection.connect[(A, B, C, D, E, F, G, H, I, J, K, L, M, N), thrift.Tuple14, Array[Byte]]

  implicit def thriftTuple15[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O](
    implicit injection: Injection[
      (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O),
      (Item, Item, Item, Item, Item, Item, Item, Item, Item, Item, Item, Item, Item, Item, Item)
    ]
  ): Injection[(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O), thrift.Tuple15] =
    new AbstractInjection[(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O), thrift.Tuple15] {
      def apply(tuple: (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O)) = {
        val (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o) = injection(tuple)
        thrift.Tuple15(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o)
      }
      override def invert(tuple: thrift.Tuple15) =
        injection.invert(
          (
            tuple.a,
            tuple.b,
            tuple.c,
            tuple.d,
            tuple.e,
            tuple.f,
            tuple.g,
            tuple.h,
            tuple.i,
            tuple.j,
            tuple.k,
            tuple.l,
            tuple.m,
            tuple.n,
            tuple.o
          )
        )
    }

  implicit def tuple15ToBytes[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O](
    implicit injection: Injection[
      (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O),
      (Item, Item, Item, Item, Item, Item, Item, Item, Item, Item, Item, Item, Item, Item, Item)
    ]
  ): Codec[(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O)] =
    Injection.connect[(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O), thrift.Tuple15, Array[Byte]]

  implicit def thriftTuple16[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P](
    implicit injection: Injection[
      (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P),
      (
        Item,
        Item,
        Item,
        Item,
        Item,
        Item,
        Item,
        Item,
        Item,
        Item,
        Item,
        Item,
        Item,
        Item,
        Item,
        Item
      )
    ]
  ): Injection[(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P), thrift.Tuple16] =
    new AbstractInjection[(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P), thrift.Tuple16] {
      def apply(tuple: (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P)) = {
        val (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p) = injection(tuple)
        thrift.Tuple16(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p)
      }
      override def invert(tuple: thrift.Tuple16) =
        injection.invert(
          (
            tuple.a,
            tuple.b,
            tuple.c,
            tuple.d,
            tuple.e,
            tuple.f,
            tuple.g,
            tuple.h,
            tuple.i,
            tuple.j,
            tuple.k,
            tuple.l,
            tuple.m,
            tuple.n,
            tuple.o,
            tuple.p
          )
        )
    }

  implicit def tuple16ToBytes[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P](
    implicit injection: Injection[
      (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P),
      (
        Item,
        Item,
        Item,
        Item,
        Item,
        Item,
        Item,
        Item,
        Item,
        Item,
        Item,
        Item,
        Item,
        Item,
        Item,
        Item
      )
    ]
  ): Codec[(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P)] =
    Injection.connect[(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P), thrift.Tuple16, Array[Byte]]

  implicit def thriftTuple17[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q](
    implicit injection: Injection[
      (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q),
      (
        Item,
        Item,
        Item,
        Item,
        Item,
        Item,
        Item,
        Item,
        Item,
        Item,
        Item,
        Item,
        Item,
        Item,
        Item,
        Item,
        Item
      )
    ]
  ): Injection[(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q), thrift.Tuple17] =
    new AbstractInjection[(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q), thrift.Tuple17] {
      def apply(tuple: (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q)) = {
        val (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q) = injection(tuple)
        thrift.Tuple17(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q)
      }
      override def invert(tuple: thrift.Tuple17) =
        injection.invert(
          (
            tuple.a,
            tuple.b,
            tuple.c,
            tuple.d,
            tuple.e,
            tuple.f,
            tuple.g,
            tuple.h,
            tuple.i,
            tuple.j,
            tuple.k,
            tuple.l,
            tuple.m,
            tuple.n,
            tuple.o,
            tuple.p,
            tuple.q
          )
        )
    }

  implicit def tuple17ToBytes[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q](
    implicit injection: Injection[
      (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q),
      (
        Item,
        Item,
        Item,
        Item,
        Item,
        Item,
        Item,
        Item,
        Item,
        Item,
        Item,
        Item,
        Item,
        Item,
        Item,
        Item,
        Item
      )
    ]
  ): Codec[(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q)] =
    Injection
      .connect[(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q), thrift.Tuple17, Array[Byte]]

  implicit def thriftTuple18[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R](
    implicit injection: Injection[
      (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R),
      (
        Item,
        Item,
        Item,
        Item,
        Item,
        Item,
        Item,
        Item,
        Item,
        Item,
        Item,
        Item,
        Item,
        Item,
        Item,
        Item,
        Item,
        Item
      )
    ]
  ): Injection[(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R), thrift.Tuple18] =
    new AbstractInjection[(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R), thrift.Tuple18] {
      def apply(tuple: (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R)) = {
        val (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r) = injection(tuple)
        thrift.Tuple18(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r)
      }
      override def invert(tuple: thrift.Tuple18) =
        injection.invert(
          (
            tuple.a,
            tuple.b,
            tuple.c,
            tuple.d,
            tuple.e,
            tuple.f,
            tuple.g,
            tuple.h,
            tuple.i,
            tuple.j,
            tuple.k,
            tuple.l,
            tuple.m,
            tuple.n,
            tuple.o,
            tuple.p,
            tuple.q,
            tuple.r
          )
        )
    }

  implicit def tuple18ToBytes[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R](
    implicit injection: Injection[
      (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R),
      (
        Item,
        Item,
        Item,
        Item,
        Item,
        Item,
        Item,
        Item,
        Item,
        Item,
        Item,
        Item,
        Item,
        Item,
        Item,
        Item,
        Item,
        Item
      )
    ]
  ): Codec[(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R)] =
    Injection
      .connect[(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R), thrift.Tuple18, Array[Byte]]

  implicit def thriftTuple19[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S](
    implicit injection: Injection[
      (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S),
      (
        Item,
        Item,
        Item,
        Item,
        Item,
        Item,
        Item,
        Item,
        Item,
        Item,
        Item,
        Item,
        Item,
        Item,
        Item,
        Item,
        Item,
        Item,
        Item
      )
    ]
  ): Injection[(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S), thrift.Tuple19] =
    new AbstractInjection[(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S), thrift.Tuple19] {
      def apply(tuple: (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S)) = {
        val (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s) = injection(tuple)
        thrift.Tuple19(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s)
      }
      override def invert(tuple: thrift.Tuple19) =
        injection.invert(
          (
            tuple.a,
            tuple.b,
            tuple.c,
            tuple.d,
            tuple.e,
            tuple.f,
            tuple.g,
            tuple.h,
            tuple.i,
            tuple.j,
            tuple.k,
            tuple.l,
            tuple.m,
            tuple.n,
            tuple.o,
            tuple.p,
            tuple.q,
            tuple.r,
            tuple.s
          )
        )
    }

  implicit def tuple19ToBytes[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S](
    implicit injection: Injection[
      (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S),
      (
        Item,
        Item,
        Item,
        Item,
        Item,
        Item,
        Item,
        Item,
        Item,
        Item,
        Item,
        Item,
        Item,
        Item,
        Item,
        Item,
        Item,
        Item,
        Item
      )
    ]
  ): Codec[(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S)] =
    Injection
      .connect[(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S), thrift.Tuple19, Array[
        Byte
      ]]

  implicit def thriftTuple20[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T](
    implicit injection: Injection[
      (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T),
      (
        Item,
        Item,
        Item,
        Item,
        Item,
        Item,
        Item,
        Item,
        Item,
        Item,
        Item,
        Item,
        Item,
        Item,
        Item,
        Item,
        Item,
        Item,
        Item,
        Item
      )
    ]
  ): Injection[(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T), thrift.Tuple20] =
    new AbstractInjection[
      (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T),
      thrift.Tuple20
    ] {
      def apply(tuple: (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T)) = {
        val (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t) = injection(tuple)
        thrift.Tuple20(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t)
      }
      override def invert(tuple: thrift.Tuple20) =
        injection.invert(
          (
            tuple.a,
            tuple.b,
            tuple.c,
            tuple.d,
            tuple.e,
            tuple.f,
            tuple.g,
            tuple.h,
            tuple.i,
            tuple.j,
            tuple.k,
            tuple.l,
            tuple.m,
            tuple.n,
            tuple.o,
            tuple.p,
            tuple.q,
            tuple.r,
            tuple.s,
            tuple.t
          )
        )
    }

  implicit def tuple20ToBytes[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T](
    implicit injection: Injection[
      (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T),
      (
        Item,
        Item,
        Item,
        Item,
        Item,
        Item,
        Item,
        Item,
        Item,
        Item,
        Item,
        Item,
        Item,
        Item,
        Item,
        Item,
        Item,
        Item,
        Item,
        Item
      )
    ]
  ): Codec[(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T)] =
    Injection
      .connect[(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T), thrift.Tuple20, Array[
        Byte
      ]]

  implicit def thriftTuple21[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U](
    implicit injection: Injection[
      (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U),
      (
        Item,
        Item,
        Item,
        Item,
        Item,
        Item,
        Item,
        Item,
        Item,
        Item,
        Item,
        Item,
        Item,
        Item,
        Item,
        Item,
        Item,
        Item,
        Item,
        Item,
        Item
      )
    ]
  ): Injection[(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U), thrift.Tuple21] =
    new AbstractInjection[
      (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U),
      thrift.Tuple21
    ] {
      def apply(tuple: (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U)) = {
        val (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u) = injection(tuple)
        thrift.Tuple21(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u)
      }
      override def invert(tuple: thrift.Tuple21) =
        injection.invert(
          (
            tuple.a,
            tuple.b,
            tuple.c,
            tuple.d,
            tuple.e,
            tuple.f,
            tuple.g,
            tuple.h,
            tuple.i,
            tuple.j,
            tuple.k,
            tuple.l,
            tuple.m,
            tuple.n,
            tuple.o,
            tuple.p,
            tuple.q,
            tuple.r,
            tuple.s,
            tuple.t,
            tuple.u
          )
        )
    }

  implicit def tuple21ToBytes[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U](
    implicit injection: Injection[
      (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U),
      (
        Item,
        Item,
        Item,
        Item,
        Item,
        Item,
        Item,
        Item,
        Item,
        Item,
        Item,
        Item,
        Item,
        Item,
        Item,
        Item,
        Item,
        Item,
        Item,
        Item,
        Item
      )
    ]
  ): Codec[(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U)] =
    Injection.connect[
      (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U),
      thrift.Tuple21,
      Array[Byte]
    ]

  implicit def thriftTuple22[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V](
    implicit injection: Injection[
      (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V),
      (
        Item,
        Item,
        Item,
        Item,
        Item,
        Item,
        Item,
        Item,
        Item,
        Item,
        Item,
        Item,
        Item,
        Item,
        Item,
        Item,
        Item,
        Item,
        Item,
        Item,
        Item,
        Item
      )
    ]
  ): Injection[(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V), thrift.Tuple22] =
    new AbstractInjection[
      (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V),
      thrift.Tuple22
    ] {
      def apply(tuple: (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V)) = {
        val (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v) = injection(tuple)
        thrift.Tuple22(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v)
      }
      override def invert(tuple: thrift.Tuple22) =
        injection.invert(
          (
            tuple.a,
            tuple.b,
            tuple.c,
            tuple.d,
            tuple.e,
            tuple.f,
            tuple.g,
            tuple.h,
            tuple.i,
            tuple.j,
            tuple.k,
            tuple.l,
            tuple.m,
            tuple.n,
            tuple.o,
            tuple.p,
            tuple.q,
            tuple.r,
            tuple.s,
            tuple.t,
            tuple.u,
            tuple.v
          )
        )
    }

  implicit def tuple22ToBytes[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V](
    implicit injection: Injection[
      (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V),
      (
        Item,
        Item,
        Item,
        Item,
        Item,
        Item,
        Item,
        Item,
        Item,
        Item,
        Item,
        Item,
        Item,
        Item,
        Item,
        Item,
        Item,
        Item,
        Item,
        Item,
        Item,
        Item
      )
    ]
  ): Codec[(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V)] =
    Injection.connect[
      (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V),
      thrift.Tuple22,
      Array[Byte]
    ]

}
