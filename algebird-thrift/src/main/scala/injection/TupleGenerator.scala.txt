// Run this generator like a script:
// scala TupleGenerator.scala.txt > GeneratedTupleImplicits.scala

/*
 * Example of the code generated:

  implicit def thriftTuple2[A, B](
    implicit injection: Injection[(A, B), (Item, Item)]): Injection[(A, B), thrift.Tuple2] =
    new AbstractInjection[(A, B), thrift.Tuple2] {
      implicit private val toBuf = Injection.connect[Item, Array[Byte], ByteBuffer]

      def apply(tuple: (A, B)) = {
        val (one, two) = injection(tuple).as[(ByteBuffer, ByteBuffer)]
        thrift.Tuple2(one, two)
      }
      override def invert(tuple: thrift.Tuple2) =
        for {
          one <- tuple.one.as[Try[Item]]
          two <- tuple.two.as[Try[Item]]
          ret <- injection.invert((one, two))
        } yield ret
    }
*/

val lowerLetters = ('a' to 'z').map { _.toString }.toIndexedSeq
val upperLetters = ('A' to 'Z').map { _.toString }.toIndexedSeq

def castParam(i: Int): String =
  "%s.asInstanceOf[%s]".format(lowerLetters(i), upperLetters(i))

def typeParam(i: Int): String =
  "%s: %s".format(lowerLetters(i), upperLetters(i))

def genParams(count: Int, sep: String = ",")(fn: Int => String): String =
  (0 until count).map { fn(_) }.mkString(sep)

// Here we put it all together:
def implicitIFn(i: Int): String = {
  val func = "thriftTuple" + i
  val types = genParams(i)(upperLetters(_))
  val variables = genParams(i)(lowerLetters(_))
  val funcName = "%s[%s]".format(func, types)
  val tupleType = "(%s)".format(types)
  val itemTuple = "(%s)".format(genParams(i)(_ => "Item"))
  val variableTuple = "(%s)".format(variables)
  val tupleCalls = "(%s)".format(genParams(i)(i => "tuple." + lowerLetters(i)))
  val bufType = "(%s)".format(genParams(i)(_ => "ByteBuffer"))
  val lines = genParams(i, sep = "\n") { i =>
    val letter = lowerLetters(i)
    "          %s <- tuple.%s.as[Try[Item]]".format(letter, letter)
  }
  """  implicit def %s(
    implicit injection: Injection[%s, %s]): Injection[%s, thrift.Tuple%d] =
    new AbstractInjection[%s, thrift.Tuple%d] {
      def apply(tuple: %s) = {
        val %s = injection(tuple)
        thrift.Tuple%d%s
      }
      override def invert(tuple: thrift.Tuple%d) =
        injection.invert(%s)
    }

  implicit def tuple%dToBytes[%s](
    implicit injection: Injection[%s, %s]
  ): Codec[%s] =
    Injection.connect[%s, thrift.Tuple%d, Array[Byte]]
""".format(
    funcName, tupleType, itemTuple, tupleType, i, tupleType, i,
  // apply starts here
  tupleType, variableTuple, i, variableTuple,
  // invert starts here
  i, tupleCalls,
  // next method
  i, types, tupleType, itemTuple, tupleType, tupleType, i
  )
}

println(
"""// Autogenerated code DO NOT EDIT BY HAND

package com.twitter.algebird_internal.injection

import com.twitter.algebird_internal.{ thriftscala => thrift }
import com.twitter.bijection.{ AbstractInjection, Codec, Conversion, Injection }

import Conversion.asMethod
import thrift.Item
import java.nio.ByteBuffer
import scala.util.Try

trait GeneratedTupleImplicits {
  import ThriftImplicits._
  implicit private val toBuf = Injection.connect[Item, Array[Byte], ByteBuffer]

"""
)
(2 to 22).map { implicitIFn(_) }.foreach { println(_) }
println("}")
